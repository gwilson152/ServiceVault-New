// Clean, optimized schema for Service Vault
// No legacy tables, clean relationships, optimized for performance

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Account type enum
enum AccountType {
  INDIVIDUAL
  ORGANIZATION
  SUBSIDIARY
}

// Email template types
enum EmailTemplateType {
  USER_INVITATION
  TICKET_UPDATE
  TICKET_STATUS_CHANGE
  TIME_ENTRY_APPROVAL
  INVOICE_GENERATED
  PASSWORD_RESET
  ACCOUNT_WELCOME
  SYSTEM_NOTIFICATION
}

enum EmailTemplateStatus {
  ACTIVE
  INACTIVE
  DRAFT
}

enum EmailQueueStatus {
  PENDING
  SENDING
  SENT
  FAILED
  CANCELLED
}

// NextAuth required models
model AuthAccount {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Core User model - simplified, no hard-coded roles
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  preferences   Json?     // User preferences (filters, UI settings, etc.)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // NextAuth relations
  authAccounts AuthAccount[]
  sessions     Session[]

  // Application relations
  memberships     AccountMembership[]  // Many-to-many with accounts
  systemRoles     SystemRole[]         // System-wide roles
  timeEntries     TimeEntry[]
  createdTickets  Ticket[]            @relation("TicketCreator")
  assignedTickets Ticket[]            @relation("TicketAssignee")
  createdInvoices Invoice[]
  timers          Timer[]
  approvedTimeEntries TimeEntry[]     @relation("TimeEntryApprover")
  
  // Email relations
  createdEmailTemplates EmailTemplate[] @relation("EmailTemplateCreator")
  updatedEmailTemplates EmailTemplate[] @relation("EmailTemplateUpdater")
  createdEmailSettings  EmailSettings[] @relation("EmailSettingsCreator")
  updatedEmailSettings  EmailSettings[] @relation("EmailSettingsUpdater")
  createdEmails         EmailQueue[]
  
  @@index([email])
}

// Clean Account model with domain auto-assignment
model Account {
  id          String      @id @default(cuid())
  name        String
  accountType AccountType @default(INDIVIDUAL)
  parentId    String?
  companyName String?
  address     String?
  phone       String?
  domains     String?     // CSV of email domains for auto-assignment
  customFields Json?      // JSONB for custom fields
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Hierarchical relations
  parent   Account?  @relation("AccountHierarchy", fields: [parentId], references: [id])
  children Account[] @relation("AccountHierarchy")

  // Application relations
  memberships AccountMembership[]
  tickets     Ticket[]
  timeEntries TimeEntry[]      // Direct time entries for account
  invoices    Invoice[]
  settings    AccountSettings?
  billingRates AccountBillingRate[]
  
  @@index([parentId])
  @@index([domains]) // For domain-based auto-assignment queries
}

// Clean many-to-many relationship between users and accounts
model AccountMembership {
  id        String   @id @default(cuid())
  userId    String
  accountId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  roles   MembershipRole[]

  @@unique([userId, accountId])
  @@index([userId])
  @@index([accountId])
}

// Role templates - all roles are defined here, no hard-coded roles
model RoleTemplate {
  id                    String   @id @default(cuid())
  name                  String   @unique
  description           String?
  permissions           String[] // Array of permission strings like ["tickets:view", "time-entries:create"]
  inheritAllPermissions Boolean  @default(false) // Super-admin flag - inherits ALL permissions
  isSystemRole          Boolean  @default(false) // Can be assigned system-wide vs account-specific
  scope                 String   @default("account") // "account" | "system" | "global"
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  membershipRoles MembershipRole[]
  systemRoles     SystemRole[]

  @@index([isSystemRole])
  @@index([inheritAllPermissions])
}

// Account membership roles - roles assigned within account context
model MembershipRole {
  id           String @id @default(cuid())
  membershipId String
  roleId       String

  membership AccountMembership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  role       RoleTemplate      @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([membershipId, roleId])
}

// System-wide roles (like super-admin)
model SystemRole {
  id     String @id @default(cuid())
  userId String
  roleId String

  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role RoleTemplate @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
}

// Ticket model - cleaned up
model Ticket {
  id           String   @id @default(cuid())
  ticketNumber String   @unique // User-friendly ticket number (e.g., ACME-2024-001)
  title        String
  description  String?
  status       String   @default("OPEN")
  priority     String   @default("MEDIUM")
  customFields Json?    // JSONB for custom fields
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  accountId    String
  creatorId    String?
  assigneeId   String?  // Agent/Employee who works on the ticket

  account  Account @relation(fields: [accountId], references: [id])
  creator  User?   @relation("TicketCreator", fields: [creatorId], references: [id])
  assignee User?   @relation("TicketAssignee", fields: [assigneeId], references: [id])

  timeEntries  TimeEntry[]
  addons       TicketAddon[]
  timers       Timer[]

  @@index([accountId])
  @@index([creatorId])
  @@index([assigneeId])
  @@index([status])
}

model TimeEntry {
  id               String    @id @default(cuid())
  description      String?
  minutes          Int       // Time in minutes
  date             DateTime  @default(now())
  noCharge         Boolean   @default(false)
  billingRateId    String?   // Reference to billing rate used
  billingRateName  String?   // Snapshot of rate name at time of entry
  billingRateValue Float?    // Snapshot of rate value at time of entry
  isApproved       Boolean   @default(false)
  approvedBy       String?   // User ID who approved the entry
  approvedAt       DateTime? // When the entry was approved
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  ticketId         String?   // Optional - supports account-direct entries
  accountId        String?   // Optional - for account-direct time entries
  userId           String

  ticket       Ticket?       @relation(fields: [ticketId], references: [id])
  account      Account?      @relation(fields: [accountId], references: [id])
  user         User          @relation(fields: [userId], references: [id])
  approver     User?         @relation("TimeEntryApprover", fields: [approvedBy], references: [id])
  billingRate  BillingRate?  @relation(fields: [billingRateId], references: [id])
  invoiceItems InvoiceItem[]

  @@index([userId])
  @@index([ticketId])
  @@index([accountId])
  @@index([date])
  @@index([isApproved])
}

model TicketAddon {
  id          String  @id @default(cuid())
  name        String
  description String?
  price       Float
  quantity    Int     @default(1)
  ticketId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ticket       Ticket        @relation(fields: [ticketId], references: [id])
  invoiceItems InvoiceItem[]

  @@index([ticketId])
}

model Invoice {
  id            String   @id @default(cuid())
  invoiceNumber String   @unique
  status        String   @default("DRAFT")
  total         Float
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  accountId     String
  creatorId     String

  account Account @relation(fields: [accountId], references: [id])
  creator User    @relation(fields: [creatorId], references: [id])
  items   InvoiceItem[]

  @@index([accountId])
  @@index([status])
}

model InvoiceItem {
  id          String  @id @default(cuid())
  description String
  quantity    Float
  rate        Float
  amount      Float
  invoiceId   String
  timeEntryId String?
  addonId     String?

  invoice   Invoice      @relation(fields: [invoiceId], references: [id])
  timeEntry TimeEntry?   @relation(fields: [timeEntryId], references: [id])
  addon     TicketAddon? @relation(fields: [addonId], references: [id])

  @@index([invoiceId])
}

model BillingRate {
  id          String  @id @default(cuid())
  name        String  @unique
  rate        Float
  description String?
  isDefault   Boolean @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  timeEntries      TimeEntry[]
  accountRates     AccountBillingRate[]
}

model AccountBillingRate {
  id            String  @id @default(cuid())
  accountId     String
  billingRateId String
  rate          Float   // Override rate for this account
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  account     Account     @relation(fields: [accountId], references: [id])
  billingRate BillingRate @relation(fields: [billingRateId], references: [id])

  @@unique([accountId, billingRateId])
}

// System settings
model SystemSettings {
  id           String @id @default(cuid())
  key          String @unique
  value        String
  customFields Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model AccountSettings {
  id           String  @id @default(cuid())
  accountId    String  @unique
  customFields Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  account Account @relation(fields: [accountId], references: [id])
}

// Timer model for persistent cross-device time tracking
model Timer {
  id         String    @id @default(cuid())
  userId     String
  ticketId   String
  startTime  DateTime  @default(now())
  pausedTime Int       @default(0) // Accumulated paused seconds
  isRunning  Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  ticket Ticket @relation(fields: [ticketId], references: [id])

  @@unique([userId, ticketId]) // One timer per ticket per user
}

// Email system
model EmailTemplate {
  id          String              @id @default(cuid())
  name        String              @unique
  type        EmailTemplateType
  subject     String
  htmlBody    String
  textBody    String?
  variables   String              @default("{}")
  isDefault   Boolean             @default(false)
  status      EmailTemplateStatus @default(ACTIVE)
  createdBy   String
  updatedBy   String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  creator User  @relation("EmailTemplateCreator", fields: [createdBy], references: [id])
  updater User? @relation("EmailTemplateUpdater", fields: [updatedBy], references: [id])

  emailQueue EmailQueue[]
}

model EmailSettings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  createdBy String
  updatedBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator User  @relation("EmailSettingsCreator", fields: [createdBy], references: [id])
  updater User? @relation("EmailSettingsUpdater", fields: [updatedBy], references: [id])
}

model EmailQueue {
  id            String           @id @default(cuid())
  templateId    String?
  fromEmail     String
  fromName      String?
  toEmail       String
  toName        String?
  ccEmails      String?
  bccEmails     String?
  subject       String
  htmlBody      String
  textBody      String?
  variables     String           @default("{}")
  status        EmailQueueStatus @default(PENDING)
  priority      Int              @default(5)
  scheduledAt   DateTime?
  sentAt        DateTime?
  failureReason String?
  retryCount    Int              @default(0)
  maxRetries    Int              @default(3)
  createdBy     String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  template EmailTemplate? @relation(fields: [templateId], references: [id])
  creator  User?          @relation(fields: [createdBy], references: [id])

  @@index([status])
  @@index([scheduledAt])
}

// User preferences - simplified
model UserPreferences {
  id           String @id @default(cuid())
  userId       String @unique
  preferences  Json   @default("{}")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
}