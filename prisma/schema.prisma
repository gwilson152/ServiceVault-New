// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User roles enum
enum Role {
  ADMIN
  EMPLOYEE
  ACCOUNT_USER
}

// Account type enum
enum AccountType {
  INDIVIDUAL
  ORGANIZATION
  SUBSIDIARY
}

// NextAuth required models
model AuthAccount {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Core application models
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          Role      @default(ACCOUNT_USER)
  accountUserId String?   @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // NextAuth relations
  authAccounts AuthAccount[]
  sessions     Session[]

  // Application relations
  timeEntries          TimeEntry[]
  createdTickets       Ticket[]           @relation("TicketCreator")
  assignedTickets      Ticket[]           @relation("TicketAssignee")
  createdInvoices      Invoice[]
  accountBillingRates  AccountBillingRate[]
  accountUser          AccountUser?       @relation(fields: [accountUserId], references: [id])
  blacklistEntries     Blacklist[]
  timers               Timer[]
  approvedTimeEntries  TimeEntry[]        @relation("TimeEntryApprover")
  userPermissions      UserPermission[]
  
  // Email relations
  createdEmailTemplates EmailTemplate[]  @relation("EmailTemplateCreator")
  updatedEmailTemplates EmailTemplate[]  @relation("EmailTemplateUpdater")
  createdEmailSettings  EmailSettings[]  @relation("EmailSettingsCreator")
  updatedEmailSettings  EmailSettings[]  @relation("EmailSettingsUpdater")
  createdEmails         EmailQueue[]
  
  // Role relations
  userRoles             UserRole[]
}

// Account model (replaces Customer)
model Account {
  id          String      @id @default(cuid())
  name        String
  accountType AccountType @default(INDIVIDUAL)
  parentAccountId String?
  companyName String?
  address     String?
  phone       String?
  customFields Json?      // JSONB for custom fields
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Hierarchical relations
  parentAccount    Account?  @relation("AccountHierarchy", fields: [parentAccountId], references: [id])
  childAccounts    Account[] @relation("AccountHierarchy")

  // Application relations
  accountUsers     AccountUser[]
  tickets          Ticket[]
  timeEntries      TimeEntry[]      // Direct time entries for account
  invoices         Invoice[]
  settings         AccountSettings?
  billingRates     AccountBillingRate[]
}

// Account users (can have login or not)
model AccountUser {
  id               String    @id @default(cuid())
  accountId        String
  userId           String?   @unique
  email            String    @unique
  name             String
  phone            String?
  isActive         Boolean   @default(true)
  invitationToken  String?   @unique
  invitationExpiry DateTime?
  permissions      Json?     // ABAC permissions
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  account Account @relation(fields: [accountId], references: [id])
  user    User?
  createdTickets Ticket[] @relation("AccountUserTicketCreator")
  accountUserRoles AccountUserRole[]
}

model Ticket {
  id           String   @id @default(cuid())
  ticketNumber String   @unique // User-friendly ticket number (e.g., ACME-2024-001)
  title        String
  description  String?
  status       String   @default("OPEN")
  priority     String   @default("MEDIUM")
  customFields Json?    // JSONB for custom fields
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  accountId    String
  creatorId    String?
  accountUserCreatorId String?
  assigneeId   String?

  account      Account      @relation(fields: [accountId], references: [id])
  creator      User?        @relation("TicketCreator", fields: [creatorId], references: [id])
  accountUserCreator AccountUser? @relation("AccountUserTicketCreator", fields: [accountUserCreatorId], references: [id])
  assignee     User?        @relation("TicketAssignee", fields: [assigneeId], references: [id])
  
  timeEntries  TimeEntry[]
  addons       TicketAddon[]
  invoiceItems InvoiceItem[]
  timers       Timer[]
}

model TimeEntry {
  id               String    @id @default(cuid())
  description      String?
  minutes          Int       // Changed from hours (Float) to minutes (Int)
  date             DateTime  @default(now())
  noCharge         Boolean   @default(false)
  billingRateId    String?   // Reference to billing rate used
  billingRateName  String?   // Snapshot of rate name at time of entry
  billingRateValue Float?    // Snapshot of rate value at time of entry
  isApproved       Boolean   @default(false)  // Approval status for invoicing
  approvedBy       String?   // User ID who approved the entry
  approvedAt       DateTime? // When the entry was approved
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  ticketId         String?   // Made optional to support account-direct entries
  accountId        String?   // Added for account-direct time entries
  userId           String

  ticket       Ticket?       @relation(fields: [ticketId], references: [id])
  account      Account?      @relation(fields: [accountId], references: [id])
  user         User          @relation(fields: [userId], references: [id])
  billingRate  BillingRate?  @relation(fields: [billingRateId], references: [id])
  approver     User?         @relation("TimeEntryApprover", fields: [approvedBy], references: [id])
  invoiceItems InvoiceItem[]
}

model TicketAddon {
  id          String  @id @default(cuid())
  name        String
  description String?
  price       Float
  quantity    Int     @default(1)
  ticketId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ticket       Ticket        @relation(fields: [ticketId], references: [id])
  invoiceItems InvoiceItem[]
}

model Invoice {
  id            String   @id @default(cuid())
  invoiceNumber String   @unique
  status        String   @default("DRAFT")
  issueDate     DateTime @default(now())
  dueDate       DateTime?
  subtotal      Float    @default(0)
  tax           Float    @default(0)
  total         Float    @default(0)
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  accountId     String
  creatorId     String

  account  Account       @relation(fields: [accountId], references: [id])
  creator  User          @relation(fields: [creatorId], references: [id])
  items    InvoiceItem[]
}

model InvoiceItem {
  id            String  @id @default(cuid())
  description   String
  quantity      Float
  rate          Float
  amount        Float
  invoiceId     String
  timeEntryId   String?
  ticketAddonId String?
  ticketId      String?

  invoice     Invoice      @relation(fields: [invoiceId], references: [id])
  timeEntry   TimeEntry?   @relation(fields: [timeEntryId], references: [id])
  ticketAddon TicketAddon? @relation(fields: [ticketAddonId], references: [id])
  ticket      Ticket?      @relation(fields: [ticketId], references: [id])
}

model BillingRate {
  id          String   @id @default(cuid())
  name        String
  description String?
  rate        Float
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  timeEntries TimeEntry[]
}

model AccountBillingRate {
  id        String   @id @default(cuid())
  rate      Float
  accountId String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account Account @relation(fields: [accountId], references: [id])
  user    User    @relation(fields: [userId], references: [id])

  @@unique([accountId, userId])
}

model SystemSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String?
  jsonValue   Json?    // JSONB for complex settings
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model AccountSettings {
  id                 String   @id @default(cuid())
  accountId          String   @unique
  canViewTimeEntries Boolean  @default(true)
  canCreateTickets   Boolean  @default(true)
  canAddTicketAddons Boolean  @default(false)
  customFields       Json?    // JSONB for custom field definitions
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  account Account @relation(fields: [accountId], references: [id])
}

model Permission {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  resource    String
  action      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Account-specific permissions for fine-grained control
model AccountPermission {
  id              String   @id @default(cuid())
  accountUserId   String
  permissionName  String
  resource        String
  action          String
  scope           String   @default("own") // own, account, subsidiary
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([accountUserId, permissionName])
}

// System user permissions for ADMIN and EMPLOYEE roles
model UserPermission {
  id              String   @id @default(cuid())
  userId          String
  permissionName  String
  resource        String
  action          String
  scope           String   @default("own") // own, account, subsidiary, global
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, permissionName])
}

// Timer model for persistent cross-device time tracking
model Timer {
  id        String    @id @default(cuid())
  userId    String
  ticketId  String
  startTime DateTime  @default(now())
  pausedTime Int      @default(0) // Accumulated paused seconds
  isRunning Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  ticket Ticket @relation(fields: [ticketId], references: [id])

  @@unique([userId, ticketId]) // One timer per ticket per user
}

// Blacklist for managing blocked users/emails
model Blacklist {
  id          String   @id @default(cuid())
  email       String?  @unique
  ipAddress   String?
  reason      String
  blockedBy   String   // User ID who created the blacklist entry
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  blocker User @relation(fields: [blockedBy], references: [id])
}

// Email template types enum
enum EmailTemplateType {
  USER_INVITATION
  TICKET_UPDATE
  TICKET_STATUS_CHANGE
  TIME_ENTRY_APPROVAL
  INVOICE_GENERATED
  PASSWORD_RESET
  ACCOUNT_WELCOME
  SYSTEM_NOTIFICATION
}

// Email template status enum
enum EmailTemplateStatus {
  ACTIVE
  INACTIVE
  DRAFT
}

// Email queue status enum
enum EmailQueueStatus {
  PENDING
  SENDING
  SENT
  FAILED
  CANCELLED
}

// Email templates for various system notifications
model EmailTemplate {
  id          String              @id @default(cuid())
  name        String              @unique
  type        EmailTemplateType
  subject     String
  htmlBody    String              // HTML content
  textBody    String?             // Plain text fallback
  variables   String              @default("{}") // JSON object of available variables
  isDefault   Boolean             @default(false) // Is this the default template for this type
  status      EmailTemplateStatus @default(ACTIVE)
  createdBy   String
  updatedBy   String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  creator User  @relation("EmailTemplateCreator", fields: [createdBy], references: [id])
  updater User? @relation("EmailTemplateUpdater", fields: [updatedBy], references: [id])

  // Relations to email queue
  emailQueue EmailQueue[]
}

// Email queue for managing outbound emails
model EmailQueue {
  id            String           @id @default(cuid())
  templateId    String?          // Optional - may be null for system-generated emails
  fromEmail     String
  fromName      String?
  toEmail       String
  toName        String?
  ccEmails      String?          // JSON array of CC email addresses
  bccEmails     String?          // JSON array of BCC email addresses
  subject       String
  htmlBody      String
  textBody      String?
  variables     String           @default("{}") // JSON object of template variables
  status        EmailQueueStatus @default(PENDING)
  priority      Int              @default(5) // 1 = highest, 10 = lowest
  scheduledAt   DateTime?        // When to send the email (null = send immediately)
  sentAt        DateTime?        // When the email was actually sent
  failureReason String?          // Error message if failed
  retryCount    Int              @default(0)
  maxRetries    Int              @default(3)
  createdBy     String?          // May be null for system-generated emails
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  template EmailTemplate? @relation(fields: [templateId], references: [id])
  creator  User?          @relation(fields: [createdBy], references: [id])

  @@index([status, scheduledAt])
  @@index([createdAt])
}

// Email settings for SMTP configuration
model EmailSettings {
  id             String   @id @default(cuid())
  smtpHost       String
  smtpPort       Int      @default(587)
  smtpUsername   String?  // Optional for servers that don't require auth
  smtpPassword   String?  // Optional for servers that don't require auth
  smtpSecure     Boolean  @default(false) // Use SSL/TLS
  fromEmail      String   // Default from email
  fromName       String   // Default from name
  replyToEmail   String?  // Default reply-to email
  isActive       Boolean  @default(true)
  testMode       Boolean  @default(false) // If true, emails are logged but not sent
  createdBy      String
  updatedBy      String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  creator User  @relation("EmailSettingsCreator", fields: [createdBy], references: [id])
  updater User? @relation("EmailSettingsUpdater", fields: [updatedBy], references: [id])
}

// Role templates for permission management
model RoleTemplate {
  id            String   @id @default(cuid())
  name          String   @unique
  description   String?
  permissions   Json     // Array of permission names (e.g., ["time-entries:view", "tickets:create"])
  isTemplate    Boolean  @default(true) // Whether this is a reusable template
  applicableTo  String   @default("system") // "system", "account", "both" - where this role can be applied
  defaultScope  String   @default("own") // "own", "account", "subsidiary" - default scope when assigned
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  userRoles        UserRole[]
  accountUserRoles AccountUserRole[]
}

// Junction table for User-Role assignments
model UserRole {
  id     String @id @default(cuid())
  userId String
  roleId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role RoleTemplate @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
}

// Junction table for AccountUser-Role assignments with scope
model AccountUserRole {
  id            String @id @default(cuid())
  accountUserId String
  roleId        String
  scope         String @default("account") // "own", "account", "subsidiary" - permission scope level
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accountUser AccountUser   @relation(fields: [accountUserId], references: [id], onDelete: Cascade)
  role        RoleTemplate  @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([accountUserId, roleId])
}